--Copyright Robert C. Taylor

import Test.Framework (defaultMain, testGroup)
import Test.Framework.Providers.QuickCheck2 (testProperty)
import Test.QuickCheck
import Test.Framework.Providers.HUnit
import Test.HUnit
import Data.Word
import OFDMRadar.Math.Misc
import qualified Data.Vector as V
import Data.List
import Data.Array
import OFDMRadar.SDR.Converters
import OFDMRadar.SDR.OFDMModulation
import OFDMRadar.SDR.DopplerRadar
import Data.Complex
import qualified Data.ByteString as B

main :: IO ()
main = defaultMain tests

tests = [
         testGroup "To Symbol Tests" [
          testCase "No Data To decode" symbolTestNoData,
          testCase "Word Size 1" symbolTestSize1,
          testCase "Word Size 2" symbolTestSize2,
          testCase "Word Size 4" symbolTestSize4
         ],
         testGroup "Symbol Extension Tests" [
          testProperty "Empty Symbol should give empty result" symbolExtensionEmpty ,
          testProperty "Test Length Extension" symbolExtensionTest
         ],
         testGroup "Symbol Encoding Test" [
          testProperty "Symbol Right Length" symbolEncodeRightLength,
          testCase "Symbol Encoding Correct BPSK" symbolEncodeCorrectBPSK,
          testCase "Symbol Encoding Correct QPSK" symbolEncodeCorrectQPSK
         ],
         testGroup "OFDM Radar Return Test" ofdmDecodeTestCases,
         testGroup "Doppler List Radar Return Test" listDopplerTestCases,
         testGroup "Doppler Vector Radar Return Test" vectorDopplerTestCases
         -- testCase "Ofdm Radar retun test size 1" ofdmRadarReturnTest1,
         -- testCase "Ofdm Radar retun test size 2" ofdmRadarReturnTest2,
         -- testCase "Ofdm Radar retun test size 4" ofdmRadarReturnTest4,
         -- testCase "Ofdm Radar retun test size 8" ofdmRadarReturnTest8,
         -- testCase "Ofdm Radar retun test size 16" ofdmRadarReturnTest16
        ]
       
symbolExtensionEmpty :: Int -> Int -> Bool
symbolExtensionEmpty lengthOfSilence cyclicLength = (extendOFDMSymbol (abs cyclicLength) (abs lengthOfSilence) []) == []


symbolExtensionTest :: Int -> Int -> [Complex Double] -> Bool
symbolExtensionTest lengthOfSilence cyclicLength symbol = (extendOFDMSymbol (abs cyclicLength) (abs lengthOfSilence) symbol) == expectedResult
    where expectedResult = if symbol == [] then [] else (reverse $ take (abs cyclicLength) $ cycle $ reverse symbol) ++ symbol ++ replicate (abs lengthOfSilence) (0 :+ 0)
       
       
symbolEncodeRightLength :: Int -> Bool 
symbolEncodeRightLength carriersPre = (length $ encodeOFDMSymbol 1 constellation carriers inputData) == carriers
    where constellation = array (0,1) [(0,1 :+ 0), (1,0 :+ 1)]
          carriers = minimum [2048, 2 ^ (discretePowerOf2 $ maximum[8,abs carriersPre])]
          inputData = B.pack $ replicate (div carriers 8) 0

          
compareDouble a b = (abs (a - b)) < 0.005
compareComplex a b = (compareDouble (realPart a) (realPart b)) && (compareDouble (imagPart a) (imagPart b))
    
    
symbolEncodeCorrectBPSK = assertEqual "Expected output was not produced" (all (\(a,b) -> compareComplex a b) (zip (encodeOFDMSymbol 1 constellation 8 inputData) expectedOutput)) True
    where inputData = B.pack [1]
          constellation = array (0,1) [(0,1 :+ 0), (1,0 :+ 1)]
          
          -- x <- c(complex(real=0,imaginary=1), complex(real=1,imaginary=0), complex(real=1,imaginary=0), complex(real=1,imaginary=0), complex(real=1,imaginary=0), complex(real=1,imaginary=0), complex(real=1,imaginary=0), complex(real=1,imaginary=0))
          -- fft(x,inverse=TRUE)/8
          -- [1]  0.875+0.125i -0.125+0.125i -0.125+0.125i -0.125+0.125i -0.125+0.125i
          --[6] -0.125+0.125i -0.125+0.125i -0.125+0.125i

          expectedOutput = [0.875 :+ 0.125,  (-0.125) :+ 0.125,  (-0.125) :+ 0.125, (-0.125) :+ 0.125, (-0.125) :+ 0.125, (-0.125) :+ 0.125, (-0.125) :+ 0.125, (-0.125) :+ 0.125]
          
          
symbolEncodeCorrectQPSK = assertEqual "Expected output was not produced" (all  (\(a,b) -> compareComplex a b) (zip (encodeOFDMSymbol 2 constellation 4 inputData) expectedOutput)) True
    where inputData = B.pack [39] -- 00100111
          constellation = array (0,3) [(0, 1.0 :+ 1.0), (1,(-1.0) :+ 1.0), (2,1.0 :+ (-1.0)), (3,(-1.0) :+ (-1.0))]
          
          -- x <- c( complex(real=-1,imaginary=-1), complex(real=-1,imaginary=1), complex(real=1, imaginary=-1), complex(real=1, imaginary=1))
          -- fft(x, inverse=TRUE)/4
          -- [1]  0.0+0.0i -0.5-0.5i  0.0-1.0i -0.5+0.5i
          
          expectedOutput = [0.0 :+ 0.0, (-0.5) :+ (-0.5),  0.0 :+ (-1.0), (-0.5) :+ 0.5]
    
    
symbolTestNoData = assertEqual "Symbol encoder should return an empty list" [] output
    where output = bytesToSymbols 1 constellation B.empty
          constellation = array (0,1) [(0,1 :+ 0), (1,0 :+ 1)] 
          
          
symbolTestSize1 = assertEqual "Symbol Pattern should match" sampleConst output
    where sampleConstBlock = B.pack [87, 170]
          constellation = array (0,1) [(0,1 :+ 0), (1,0 :+ 1)]
          output = reverse $ bytesToSymbols 1 constellation sampleConstBlock
          sampleConst = [(0 :+ 1), (0 :+ 1), (0 :+ 1), (1 :+ 0), (0 :+ 1), (1 :+ 0), (0 :+ 1), (1 :+ 0)] ++ [ 1:+ 0, 0 :+ 1, 1 :+ 0, 0 :+ 1, 1:+ 0, 0 :+ 1, 1 :+ 0, 0 :+ 1]

          
symbolTestSize2 = assertEqual "Symbol Pattern should match" sampleConst output
    where sampleConstBlock = B.pack [87, 170]
          constellation = array (0,3) [(0,1 :+ 0), (1,0 :+ 1), (2,1 :+ 1), (3, 2 :+ 2)]
          output = reverse $ bytesToSymbols 2 constellation sampleConstBlock
          sampleConst = [(2 :+ 2), (0 :+ 1), (0 :+ 1), (0 :+ 1)] ++ [ (1 :+ 1), (1 :+ 1), (1 :+ 1), (1 :+ 1)]

          
symbolTestSize4 = assertEqual "Symbol Pattern should match" sampleConst output
    where sampleConstBlock = B.pack [87, 170]
          constellation = array (0,15) [(0,1 :+ 0), (1,0 :+ 1), (2,1 :+ 1), (3, 2 :+ 2), (4,4 :+ 4), (5,5:+5),(6,6:+6),(7,7:+7),(8,8:+8),(9,9:+9),(10,10.0:+10.0),(11,11:+11),(12,12:+12),(13,13:+13),(14,14:+14),(15,15:+15)]
          output = reverse $ bytesToSymbols 4 constellation sampleConstBlock
          sampleConst = [7 :+ 7, 5 :+ 5] ++ [10.0 :+ 10.0, 10.0 :+ 10.0 ]
          
processOfdmRadarReturnVFlat a b c = concat $ map (\a -> V.toList a) (V.toList $ processOfdmRadarReturnV a b c)
processDopplerReturnFlatten a = concat $ processDopplerReturn a
processDopplerReturnFlattenV a = concat $ map (\a -> V.toList a) (V.toList $  processDopplerReturnV a)



    
